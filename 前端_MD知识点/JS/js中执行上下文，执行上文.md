# js中执行上下文，执行上文

执行上下文是 JavaScript 中非常重要的概念之一，它是指在代码执行期间所处的环境，包含了当前执行的代码所需的所有变量、函数以及对外部环境的引用等信息。每当 JavaScript 运行一个函数时，都会创建一个新的执行上下文。
ddd
执行上下文可以分为三种类型：

1. 全局执行上下文（Global Execution Context）：当 JavaScript 代码开始执行时，会首先创建一个全局执行上下文，并将其压入执行上下文栈中。在整个程序的执行期间，全局执行上下文只会被创建一次。
2. 函数执行上下文（Function Execution Context）：每当 JavaScript 运行一个函数时，都会创建一个新的函数执行上下文，并将其压入执行上下文栈中。当函数执行完毕后，该函数执行上下文会从栈中弹出，控制权交回给调用该函数的上下文。
3. eval 函数执行上下文（Eval Function Execution Context）：当 JavaScript 执行一个 eval 函数时，会创建一个新的 eval 函数执行上下文，并将其压入执行上下文栈中。eval 函数执行上下文的行为与函数执行上下文类似。

执行上下文包含了以下三个重要成分：

1. 变量对象（Variable Object，VO）：用于存储当前执行上下文中定义的变量和函数声明。在函数执行上下文中，变量对象被称为“活动对象”（Active Object，AO）。
2. 作用域链（Scope Chain）：用于查找变量和函数。作用域链是一个指向变量对象的指针列表，它保证了执行上下文中变量和函数的有序访问。
3. this 值：用于指定当前执行上下文所属的对象。

下面是一个示例代码：

```javascript
function foo() {
  var x = 1;
  function bar() {
    var y = 2;
    console.log(x + y);
  }
  bar();
}
foo();
```

在执行上面的代码时，会依次创建以下执行上下文：

1. 全局执行上下文：包含变量对象（VO）、作用域链和 this 值。
2. 函数执行上下文（foo）：包含变量对象（AO）、作用域链和 this 值。
3. 函数执行上下文（bar）：包含变量对象（AO）、作用域链和 this 值。

在这个过程中，全局执行上下文是第一个被创建的执行上下文，它包含了全局变量和函数声明。然后在执行 `foo()` 函数时，会创建一个新的函数

U

继续 



执行上下文（Execution Context）是指 JavaScript 代码执行时所处的环境，包括变量、函数、作用域链等。JavaScript 中执行上下文有三种类型：全局执行上下文、函数执行上下文和 eval 执行上下文。

全局执行上下文是最外层的执行上下文，它是默认的、最基础的执行上下文，当 JavaScript 代码开始执行时，首先会创建一个全局执行上下文。

函数执行上下文是在函数调用时创建的执行上下文，每次调用函数都会创建一个新的函数执行上下文。

eval 执行上下文是在 eval 函数执行时创建的执行上下文。

执行上下文中主要包含了以下的内容：

1. 变量对象（Variable Object）：包括变量、函数声明和形参等。
2. 作用域链（Scope Chain）：指向所有父级执行上下文的变量对象的集合，用于查找变量和函数。
3. this 值（this）：指向当前执行上下文所属的对象。

举个例子：

```javascript
var a = 1;

function foo() {
  var b = 2;
  function bar() {
    var c = 3;
    console.log(a + b + c);
  }
  bar();
}

foo(); // 输出 6
```

执行上下文的创建顺序是：

1. 创建全局执行上下文。
2. 创建 foo 函数执行上下文，将变量对象添加到作用域链，作用域链变成 [fooVO, globalVO]。
3. 创建 bar 函数执行上下文，将变量对象添加到作用域链，作用域链变成 [barVO, fooVO, globalVO]。
4. bar 函数执行完毕，将 bar 函数执行上下文从执行栈中弹出，作用域链变成 [fooVO, globalVO]。
5. foo 函数执行完毕，将 foo 函数执行上下文从执行栈中弹出，作用域链变成 [globalVO]。
6. 全局执行上下文执行完毕。

U

eval函数执行上下文什么



`eval()` 函数是 JavaScript 的一个内置函数，它接收一个字符串作为参数，将其作为 JavaScript 代码进行编译和执行。由于 `eval()` 函数的特殊性质，它的执行上下文和普通函数的执行上下文有所不同。

当 `eval()` 函数被调用时，会创建一个新的执行上下文，称为 *eval 执行上下文*。它有以下几个特点：

- 它不在原型链上，只能访问全局作用域中的变量和函数。
- 代码在执行时，`eval()` 函数所在的作用域被视为正在执行的上下文。
- 如果传递给 `eval()` 的代码中包含函数定义，那么这些函数定义会在 *eval 执行上下文* 中创建。
- 如果传递给 `eval()` 的代码中包含 `with` 语句，那么该语句会创建一个新的词法环境，该环境包含了 `eval()` 函数所在的作用域中的变量和函数。

下面是一个使用 `eval()` 函数的例子：

```javascript
let x = 1;
let y = eval('x + 1');
console.log(y); // 2
```

在这个例子中，当 `eval()` 函数被调用时，会创建一个新的 *eval 执行上下文*。在这个上下文中，可以访问全局作用域中的变量 `x`，并进行计算。最终返回的结果是 `2`，保存在变量 `y` 中。

U

在eval中定义一个函数或变量，外部能使用吗



可以使用，但是需要注意以下几点：

1. 在严格模式下，eval内部定义的变量和函数不会被外部访问到。
2. eval内部定义的变量和函数会被覆盖外部同名变量和函数。
3. 在非严格模式下，eval内部定义的变量和函数会被提升到整个函数的作用域，可能会对整个函数产生影响。

因此，在使用eval时，应该避免在内部定义同名变量或函数，以避免出现意外的结果。

U

举个例子



可以，使用eval在当前作用域中定义的函数或变量可以在eval外部访问和调用。

例如：

```arcade
var x = 1;
eval("var y = 2; function add(a, b) { return a + b; }");
console.log(x); // 1
console.log(y); // 2
console.log(add(2, 3)); // 5
```

在上面的例子中，使用eval在当前作用域中定义了变量y和函数add，然后在eval外部可以访问和调用它们。

U

举一个严格模式下失效的例子



好的，下面是一个严格模式下失效的例子：

```js
'use strict';

function myFunction() {
  eval("var x = 2");
  console.log(x);
}

myFunction(); // 抛出错误：Uncaught ReferenceError: x is not defined
```

在严格模式下，使用`eval`创建的变量不会被添加到当前函数的词法环境中，而是被添加到一个新的词法环境中。因此，上面的例子中在`eval`中创建的变量`x`不会被添加到`myFunction`的词法环境中，而是在一个新的词法环境中，所以在`myFunction`中无法访问`x`。

U

eval函数中定义的变量在全局上下文？



在非严格模式下，eval函数中定义的变量会被绑定到当前的执行上下文中，如果eval函数在全局上下文中执行，那么定义的变量会成为全局变量。

但在严格模式下，eval函数中定义的变量不会被绑定到当前执行上下文中，也不会成为全局变量。在eval函数中定义的变量只能在eval函数的作用域内访问，不会对外部产生影响。

下面是一个在非严格模式下定义全局变量的例子：

```javascript
eval('var a = 123;');
console.log(a); // 123
```

下面是一个在严格模式下定义变量的例子：

```javascript
'use strict';
eval('var a = 123;');
console.log(a); // Uncaught ReferenceError: a is not defined
```

在严格模式下，由于eval函数中定义的变量不会成为全局变量，因此在外部访问时会报错。
